'use strict';
import React from 'react';
import Slide from '../component_slider/slide';
import Markdown from './markdown';
import { CodeBlock, Prompt, Output } from './codeblock';
import FileBlock from './fileblock';

module.exports = React.createClass ({
    render() {
      return (
        <Slide>
          <h1>Inspecting your service and next steps</h1>
          <p>Let's inspect what has actually been generated by Kubernetes based on our manifest. This first command lists all deployments, filtered to those that have a label <code>app: helloworld</code>:</p>

          <CodeBlock>
            <Prompt>
              {`kubectl get deployment -l app=helloworld`}
            </Prompt>
            <Output>
              {`
                NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
                helloworld   2         2         2            2           2m
              `}
            </Output>
          </CodeBlock>

          <p>It should tell us that 2 of our 2 desired pods are currently running. Then we list the available services with the according label:</p>

          <CodeBlock>
            <Prompt>
              {`kubectl get svc -l app=helloworld`}
            </Prompt>
            <Output>
              {`
                NAME         CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
                helloworld   10.100.70.153   <none>        80/TCP    2m
              `}
            </Output>
          </CodeBlock>

          <p>And finally we list the pods:</p>

          <CodeBlock>
            <Prompt>
              {`kubectl get pods -l app=helloworld`}
            </Prompt>
            <Output>
              {`
                NAME                          READY     STATUS    RESTARTS   AGE
                helloworld-3495070191-0ynir   1/1       Running   0          3m
                helloworld-3495070191-onuik   1/1       Running   0          3m
              `}
            </Output>
          </CodeBlock>

          <p>The exact pod names vary in each case, the first suffix functions a bit like a version number for your deployment, this changes with updates to the deployment. The last part of the pod name is used by Kubernetes to disambiguate the name using a unique suffixes.</p>

          <p>To investigate a bit closer what our containers are doing inside their pods, we can look at their logs, one pod at a time. Be sure to replace the version and suffix fields (in brackets) with the actual ones you got from the `get pods` command above.</p>

          <CodeBlock>
            <Prompt>
              {`kubectl logs helloworld-<version>-<suffix>`}
            </Prompt>
            <Output>
              {`
                2016/05/20 10:00:00 Starting up at :8080
                2016/05/20 10:03:19 GET /
              `}
            </Output>
          </CodeBlock>

          <CodeBlock>
            <Prompt>
              {`kubectl logs <helloworld-<version>-<suffix>`}
            </Prompt>
            <Output>
              {`
                2016/05/20 10:00:07 Starting up at :8080
                2016/05/20 10:03:19 GET /giantswarm_logo_standard_white.svg
                2016/05/20 10:03:19 GET /blue-bg.jpg
              `}
            </Output>
          </CodeBlock>

          <p>You should see in the log entries that the requests for the HTML page, the logo, and the background images have been distributed over both running pods and their respective containers pretty much randomly.</p>
          <p>To clean things up, we use the <code>kubectl delete</code> command on the service, deployment, and ingress we created initially:</p>

          <CodeBlock>
            <Prompt>
              {`kubectl delete service,deployment,ingress helloworld`}
            </Prompt>
            <Output>
              {`
                service "helloworld" deleted
                deployment "helloworld" deleted
                ingress "helloworld" deleted
              `}
            </Output>
          </CodeBlock>

          <p>Congratulations! You have created - and destroyed - your first application on your brand new Kubernetes cluster on Giant Swarm.</p>

          <h3>Next Steps</h3>

          <p>Now that you have a running Kubernetes cluster, you can use it to deploy anything you like on it.</p>

          <p>We recommend to <a href='https://blog.giantswarm.io/getting-started-with-a-local-kubernetes-environment/' target='_blank'>choose a local development environment</a> so you can test your apps before deploying to your Giant Swarm cluster.</p>

          <p>If you have not done so already, you should get acquainted with the <a href='https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-i-introduction-to-pods-labels-replicas/' target='_blank'>basic concepts of Kubernetes</a>.</p>

          <p>Last but not least, you should check out our <a href='https://docs.giantswarm.io/' target='_blank'>Documentation</a>, including an <a href='https://docs.giantswarm.io/basics/kubernetes-fundamentals/' target='_blank'>overview of Kubernetes Fundamentals</a> and a selection of <a href='https://docs.giantswarm.io/guides/' target='_blank'>User Guides</a> that help you set up Monitoring, Logging, and more.</p>

          <div className="component_slider--nav">
            <button onClick={this.props.goToSlide.bind(null, 'example')}>Previous</button>
          </div>
        </Slide>
      );
    }
});
